<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-gb" xml:lang="en-gb" data-mc-search-type="Stem" data-mc-help-system-file-name="Model Developer Guide.xml" data-mc-path-to-help-system="../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-medium="non-print" data-mc-toc-path="Custom Modelling in gPROMS|Distributed Models">
    <!-- saved from url=(0016)http://localhost -->
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Specifying Discretisation Methods</title>
        <link href="../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" />
        <link href="../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" />
        <link href="../Resources/Stylesheets/GeneralStyles.css" rel="stylesheet" />
        <link href="../Resources/TableStyles/GeneralTable.css" rel="stylesheet" />
        <script src="../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <p class="MCWebHelpFramesetLink MCWebHelpFramesetLinkTop"><a href="../../Model Developer Guide.htm#Topics/x2564.html">Open topic with navigation</a>
        </p>
        <div>
            <div class="nocontent">
                <div class="MCBreadcrumbsBox_0 breadcrumbs" data-mc-breadcrumbs-divider=" &gt; " data-mc-breadcrumbs-count="5" data-mc-toc="True"><span class="MCBreadcrumbsPrefix">You are here: </span>
                </div>
            </div>
        </div>
        <h1><a name="distributedsolutionmethods"></a>Specifying Discretisation Methods</h1>
        <p>The solution of systems of IPDAEs is generally a difficult problem. Changing the value of a parameter or one of the boundary conditions may
 lead to completely different behaviour from that originally anticipated. Furthermore, although some numerical methods can accurately solve a given
 system, other numerical methods may be totally unable to do so.</p>
        <p>The systems of IPDAEs defined within gPROMS Models are solved using the method-of-lines family of numerical methods. This involves
 discretisation of the distributed equations with respect to all spatial domains, which reduces the problem to the solution of a set of
 DAEs.</p>
        <p>A number of different techniques fall within the method-of-lines family of methods, depending on the discretisation scheme used for
 discretising the spatial domains. Ideally, this discretisation scheme should be selected automatically â€“ or, indeed, a single discretisation
 method that can deal efficiently with all forms of equations and boundary conditions would be desirable. However, this is not technically feasible
 at the moment and therefore gPROMS relies on the user to specify the preferred discretisation method. Three specifications are necessary to
 completely determine most discretisation methods:</p>
        <ul>
            <li value="1">
                <p><i class="emphasis">Type of spatial discretisation method</i>. The proper choice of the discretisation method is often the critical
 decision for solving a system of IPDAEs. As we mentioned earlier, because no method is reliable for all problems, the incorrect choice of
 method may lead to physically unrealistic solutions, or even fail to obtain any results.</p>
            </li>
            <li value="2">
                <p><i class="emphasis">Order of approximation</i>. The order of approximation for partial derivatives and integrals in finite difference
 methods, and the degree of polynomials used in finite element methods has a great influence on the accuracy of the solution. This is
 especially true if coarse grids or only a small number of elements are used.</p>
            </li>
            <li value="3">
                <p><i class="emphasis">Number of discretisation intervals/elements</i>. The number of discretisation intervals in finite difference methods
 and the number of elements in finite element methods are also of great significance in determining the solution trajectory. A coarse grid or a
 small number of elements for a steep gradient problem may result in an unacceptably inaccurate solution. On the other hand, too fine a grid or
 too many elements will increase the required computational efforts drastically, leading to an inefficient solution procedure.</p>
            </li>
        </ul>
        <p>The gPROMS language allows users to specify all three characteristics. DISTRIBUTION_DOMAINs are treated as Parameters and can be Set to the
 desired discretisation method, order and granularity of approximation. The table below lists the currently available numerical methods, their
 corresponding keywords in the language and the currently supported orders of approximation for each.</p>
        <div class="table"><a name="AEN2580"></a>
            <table style="mc-table-style: url('../Resources/TableStyles/GeneralTable.css');margin-left: auto;margin-right: auto;" class="TableStyle-GeneralTable" cellspacing="0">
                <caption>Numerical methods for distributed systems in gPROMS</caption>
                <thead>
                    <tr class="TableStyle-GeneralTable-Head-Header1">
                        <th align="center" class="TableStyle-GeneralTable-HeadE-Column1-Header1">Numerical method</th>
                        <th align="center" class="TableStyle-GeneralTable-HeadE-Column1-Header1">Keyword</th>
                        <th align="center" class="TableStyle-GeneralTable-HeadD-Column1-Header1">Order(s)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr class="TableStyle-GeneralTable-Body-Body1">
                        <td class="TableStyle-GeneralTable-BodyE-Column1-Body1">Centered finite difference method</td>
                        <td class="TableStyle-GeneralTable-BodyE-Column1-Body1">CFDM</td>
                        <td class="TableStyle-GeneralTable-BodyD-Column1-Body1">2, 4, 6</td>
                    </tr>
                    <tr class="TableStyle-GeneralTable-Body-Body2">
                        <td class="TableStyle-GeneralTable-BodyE-Column1-Body2">Backward finite difference method</td>
                        <td class="TableStyle-GeneralTable-BodyE-Column1-Body2">BFDM</td>
                        <td class="TableStyle-GeneralTable-BodyD-Column1-Body2">1, 2</td>
                    </tr>
                    <tr class="TableStyle-GeneralTable-Body-Body1">
                        <td class="TableStyle-GeneralTable-BodyE-Column1-Body1">Forward finite difference method</td>
                        <td class="TableStyle-GeneralTable-BodyE-Column1-Body1">FFDM</td>
                        <td class="TableStyle-GeneralTable-BodyD-Column1-Body1">1, 2</td>
                    </tr>
                    <tr class="TableStyle-GeneralTable-Body-Body2">
                        <td class="TableStyle-GeneralTable-BodyB-Column1-Body2">Orthogonal collocation on finite elements method</td>
                        <td class="TableStyle-GeneralTable-BodyB-Column1-Body2">OCFEM</td>
                        <td class="TableStyle-GeneralTable-BodyA-Column1-Body2">2, 3, 4</td>
                    </tr>
                </tbody>
            </table>
        </div>
        <p>As was mentioned earlier, the numerical methods applied to integrals depend on the nature of the integrand. If the integrand is an
 expression involving only the integration variable, then the integration method is fixed (since there is no way to specify the method). These
    <i class="emphasis">implicit</i> integrals are all evaluated using 5th order Gaussian Quadrature. If the integrand involves one or more distributed
 Model Variables, then the method of the integration is <i class="emphasis">explicitly</i> specified (because all distributed Variables must be
 defined over a Distribution Domain, which must be set a value as described in the table above). The following procedure below is applied to any
 integrals of this nature.</p>
        <ol type="1">
            <li value="1">
                <p>First, if the integral is defined over more than one domain, it is decomposed into a nested set of 1-D integrations. The innermost
 integrals are evaluated first, which provide terms in the integrands at the next level, which now become ordinary 1-D integrals themselves.
 This procedure is repeated until the outermost integral (i.e. the one with the highest dimension) has been evaluated.</p>
            </li>
            <li value="2">
                <p>Each of the 1-D integrals that must be evaluated in step 1 are first decomposed into a sum of integrals over a set of subintervals.
 This is based on the range of the Distribution Domain and number of intervals specified in its numerical method. This gives a number of
 interval boundaries, <span class="inlinemediaobject"><img src="../Resources/Images/inlinevar_xi.png" data-mc-conditions="Default.ScreenOnly" /></span>. An integral of the form</p>
                <p><span class="inlinemediaobject"><img src="../Resources/Images/inlineqn_integral_before.png" data-mc-conditions="Default.ScreenOnly" /></span>
                </p>
                <p>then becomes</p>
                <p><span class="inlinemediaobject"><img src="../Resources/Images/inlineqn_integral_after.png" data-mc-conditions="Default.ScreenOnly" /></span>.</p>
                <p>So, if the integral is specified over the interval [a,b] within a Distribution Domain defined to be over the interval [0,L] with a
 numerical method using N intervals, the number of subintervals used for the integration will be roughly (b-a)N/L.</p>
            </li>
            <li value="3">
                <p>Each of the subintegrals in step 2 is integrated using a polynomial approximation consistent with the numerical method specified for
 the Distribution Domain.</p>
            </li>
        </ol>Overall, the numerical methods for evaluating integrals do not in general correspond to any well-known methods. In some cases, the
 methods may reduce to trapezoidal or Simpson's rules; but not always. However, and most importantly, the method that is applied is always
 consistent with the numerical method used to approximate the partial derivatives over the same Distribution Domain.<p>The numerical methods applied to the various integrals that may be encountered in gPROMS Models are summarised in the table below.</p><div class="table"><a name="AEN2639"></a><table style="mc-table-style: url('../Resources/TableStyles/GeneralTable.css');margin-left: auto;margin-right: auto;" class="TableStyle-GeneralTable" cellspacing="0"><caption>Numerical methods for integrals in gPROMS</caption><thead><tr class="TableStyle-GeneralTable-Head-Header1"><th align="center" class="TableStyle-GeneralTable-HeadE-Column1-Header1">Type of integral</th><th align="center" class="TableStyle-GeneralTable-HeadE-Column1-Header1">Numerical method used</th><th align="center" class="TableStyle-GeneralTable-HeadD-Column1-Header1">Number of intervals</th></tr></thead><tbody><tr class="TableStyle-GeneralTable-Body-Body1"><td class="TableStyle-GeneralTable-BodyE-Column1-Body1">Implicit</td><td class="TableStyle-GeneralTable-BodyE-Column1-Body1">5th order, six point Gaussian Quadrature</td><td class="TableStyle-GeneralTable-BodyD-Column1-Body1">â€“</td></tr><tr class="TableStyle-GeneralTable-Body-Body2"><td class="TableStyle-GeneralTable-BodyB-Column1-Body2">Explicit</td><td class="TableStyle-GeneralTable-BodyB-Column1-Body2">approximation is consistent with numerical method used to approximate partial derivatives</td><td class="TableStyle-GeneralTable-BodyA-Column1-Body2">depends on the Distribution Domain and the integration interval</td></tr></tbody></table></div><p>Clearly, the numerical methods used in evaluating integrals have a direct effect on the accuracy of the solution. There are some situations
 where the Gaussian Quadradure used in evalulating implicit integrals results in significant errors. One example is the power function
    <span class="inlinemediaobject"><img src="../Resources/Images/power.png" data-mc-conditions="Default.ScreenOnly" /></span>. When <span class="inlinemediaobject"><img src="../Resources/Images/powerrange.png" data-mc-conditions="Default.ScreenOnly" /></span>, the results of the numerical integration can be quite poor. Of course, when the integral can be solved analytically, it is
 always better to include the analytical expression rather than the integral, as in this case. However, should numerical integration be required,
 greater accuracy can sometimes be achieved by defining a distributed Variable (over a newly specified domain), equating it to the integrand and
 then integrating the Variable. Then, the number of elements can be specified such that the accuracy of the integral is as required. An example of
 this is shown below.</p><pre class="programlisting">DISTRIBUTION_DOMAIN
 MyIntegrationDomain AS [1:100]

 VARIABLE
 Integrand AS DISTRIBUTION(MyIntegrationDomain) OF NoType
 Implicit AS NoType
 Explicit AS NoType

 SET
 MyIntegrationDomain := [ BFDM, 1, 200 ] ;

 EQUATION
 FOR x := 1 TO 100 DO
 Integrand(x) = 1/x ;
 END
 Implicit = INTEGRAL( x := 1:100; 1/x ) ;
 Explicit = INTEGRAL( x := 1:100; Integrand(x) ) ;</pre>Here, the same integration is performed using the two methods. The implicit
 method will be quite inaccurate, whereas the explicit one will be much better (depending on the order and number of elements specified for
 MyIntegrationDomain).<div class="example" data-mc-autonum="&lt;b&gt;Example&lt;/b&gt;"><span class="autonumber"><span><b>Example</b></span></span><a name="AEN2671"></a><p><b>Example 3. Setting the discretisation methods, orders and granularities</b></p><pre class="programlisting"># PROCESS StartUpSimulation

 UNIT
 R101 IS TubularReactor
 ...

 SET
 R101.Axial := [ CFDM, 2, 150] ;
 R101.Radial := [ OCFEM, 3, 4] ;
 ...</pre><p>An excerpt from a Process entity involving an instance <code class="methodname">R101</code> of a 2D tubular reactor Model. The
      <code class="methodname">Axial</code> domain within this instance is to be discretised using centered finite differences of second order over a uniform
 grid of 150 intervals. On the other hand, the <code class="methodname">Radial</code> domain is to be handled using third order orthogonal collocation
 over four finite elements. Note that the specification of discretisation methods is done separately for each distribution domain in each
 instance of the corresponding Model, thus allowing maximal flexibility in this respect.</p><p>Similarly to other Parameters, although it is possible to specify numerical solution method information within the Models themselves, in
 the interests of model reusability and generality, is often better to associate these with the specific instances of Models that are included in
 Processes.</p></div><div><p class="Footer">&#160;</p><p class="Footer">&#160;</p><hr width="100%" size="0" align="center" /><p class="Footer">Commercial in confidence</p><p class="Footer">Â© 2017 Process Systems Enterprise Limited</p></div></body>
</html>